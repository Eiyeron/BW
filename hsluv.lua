-- Generated by Haxe 3.4.2 (git build master @ 890f8c7)
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
Int = (function() _hxClasses.Int = _hx_o({__fields__={__name__=true},__name__={"Int"}}); return _hxClasses.Int end)();
Dynamic = (function() 
_hxClasses.Dynamic = _hx_o({__fields__={__name__=true},__name__={"Dynamic"}}); return _hxClasses.Dynamic end)();
Float = (function() 
_hxClasses.Float = _hx_e(); return _hxClasses.Float end)();
Float.__name__ = {"Float"}
Bool = (function() 
_hxClasses.Bool = _hx_e(); return _hxClasses.Bool end)();
Bool.__ename__ = {"Bool"}
Class = (function() 
_hxClasses.Class = _hx_o({__fields__={__name__=true},__name__={"Class"}}); return _hxClasses.Class end)();
Enum = _hx_e();

local _hx_exports = _hx_exports or {}
_hx_exports["hsluv"] = _hx_exports["hsluv"] or _hx_e()
_hx_exports["hsluv"]["Hsluv"] = _hx_exports["hsluv"]["Hsluv"] or _hx_e()
local Array = _hx_e()
local Math = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local haxe = {}
haxe.io = {}
haxe.io.Eof = _hx_e()
local hsluv = {}
hsluv.Geometry = _hx_e()
hsluv.Hsluv = _hx_e()
local lua = {}
lua.Boot = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw

Array.new = {}
Array.prototype = _hx_a(
  'join', function(self,sep) 
    local tbl = ({});
    local _gthis = self;
    local cur_length = 0;
    local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end});
    while (i:hasNext()) do 
      local i1 = i:next();
      _G.table.insert(tbl,Std.string(i1));
      end;
    do return _G.table.concat(tbl,sep) end
  end,
  'push', function(self,x) 
    _G.rawset(self,self.length,x);
    _G.rawset(self,"length",self.length + 1);
    do return _G.rawget(self,"length") end
  end,
  'iterator', function(self) 
    local _gthis = self;
    local cur_length = 0;
    do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
      do return cur_length < _gthis.length end;
    end,next=function(self) 
      cur_length = cur_length + 1;
      do return _gthis[cur_length - 1] end;
    end}) end
  end
)

Math.new = {}
Math.isNaN = function(f) 
  do return f ~= f end;
end

String.new = {}
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        do return String.__oldindex[k] end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a(
  'toLowerCase', function(self) 
    do return _G.string.lower(self) end
  end,
  'indexOf', function(self,str,startIndex) 
    if (startIndex == nil) then 
      startIndex = 1;
    else
      startIndex = startIndex + 1;
    end;
    local r = _G.string.find(self,str,startIndex,true);
    if ((r ~= nil) and (r > 0)) then 
      do return r - 1 end;
    else
      do return -1 end;
    end;
  end,
  'toString', function(self) 
    do return self end
  end,
  'charAt', function(self,index) 
    do return _G.string.sub(self,index + 1,index + 1) end
  end
)

Std.new = {}
Std.string = function(s) 
  do return lua.Boot.__string_rec(s) end;
end
Std.int = function(x) 
  if (not ((x > -_G.math.huge) and (x < _G.math.huge)) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end

haxe.io.Eof.new = {}
haxe.io.Eof.prototype = _hx_a(
  'toString', function(self) 
    do return "Eof" end
  end
)

hsluv.Geometry.new = {}
hsluv.Geometry.intersectLineLine = function(a,b) 
  local x = (a.intercept - b.intercept) / (b.slope - a.slope);
  local y = (a.slope * x) + a.intercept;
  do return _hx_o({__fields__={x=true,y=true},x=x,y=y}) end;
end
hsluv.Geometry.distanceFromOrigin = function(point) 
  do return _G.math.sqrt(_G.math.pow(point.x,2) + _G.math.pow(point.y,2)) end;
end
hsluv.Geometry.distanceLineFromOrigin = function(line) 
  do return _G.math.abs(line.intercept) / _G.math.sqrt(_G.math.pow(line.slope,2) + 1) end;
end
hsluv.Geometry.perpendicularThroughPoint = function(line,point) 
  local slope = -1 / line.slope;
  local intercept = point.y - (slope * point.x);
  do return _hx_o({__fields__={slope=true,intercept=true},slope=slope,intercept=intercept}) end;
end
hsluv.Geometry.angleFromOrigin = function(point) 
  do return _G.math.atan2(point.y,point.x) end;
end
hsluv.Geometry.normalizeAngle = function(angle) 
  local m = 2 * _G.math.pi;
  do return _G.math.fmod(((_G.math.fmod(angle, m)) + m), m) end;
end
hsluv.Geometry.lengthOfRayUntilIntersect = function(theta,line) 
  do return line.intercept / (_G.math.sin(theta) - (line.slope * _G.math.cos(theta))) end;
end

hsluv.Hsluv.new = {}
hsluv.Hsluv.getBounds = function(L) 
  local result = _hx_tab_array({ }, 0);
  local sub1 = _G.math.pow(L + 16,3) / 1560896;
  local sub2 = (function() 
    local _hx_1
    if (sub1 > hsluv.Hsluv.epsilon) then 
    _hx_1 = sub1; else 
    _hx_1 = L / hsluv.Hsluv.kappa; end
    return _hx_1
  end )();
  local _g = 0;
  while (_g < 3) do 
    _g = _g + 1;
    local c = _g - 1;
    local m1 = hsluv.Hsluv.m[c][0];
    local m2 = hsluv.Hsluv.m[c][1];
    local m3 = hsluv.Hsluv.m[c][2];
    local _g1 = 0;
    while (_g1 < 2) do 
      _g1 = _g1 + 1;
      local t = _g1 - 1;
      local top1 = ((284517 * m1) - (94839 * m3)) * sub2;
      local top2 = (((((838422 * m3) + (769860 * m2)) + (731718 * m1)) * L) * sub2) - ((769860 * t) * L);
      local bottom = (((632260 * m3) - (126452 * m2)) * sub2) + (126452 * t);
      result:push(_hx_o({__fields__={slope=true,intercept=true},slope=top1 / bottom,intercept=top2 / bottom}));
      end;
    end;
  do return result end;
end
hsluv.Hsluv.maxSafeChromaForL = function(L) 
  local bounds = hsluv.Hsluv.getBounds(L);
  local min = 1.7976931348623157e+308;
  local _g = 0;
  while (_g < 2) do 
    _g = _g + 1;
    local i = _g - 1;
    local length = hsluv.Geometry.distanceLineFromOrigin(bounds[i]);
    if (Math.isNaN(min) or Math.isNaN(length)) then 
      min = (0/0);
    else
      min = _G.math.min(min,length);
    end;
    end;
  do return min end;
end
hsluv.Hsluv.maxChromaForLH = function(L,H) 
  local hrad = ((H / 360) * _G.math.pi) * 2;
  local bounds = hsluv.Hsluv.getBounds(L);
  local min = 1.7976931348623157e+308;
  local _g = 0;
  while (_g < bounds.length) do 
    local bound = bounds[_g];
    _g = _g + 1;
    local length = hsluv.Geometry.lengthOfRayUntilIntersect(hrad,bound);
    if (length >= 0) then 
      if (Math.isNaN(min) or Math.isNaN(length)) then 
        min = (0/0);
      else
        min = _G.math.min(min,length);
      end;
    end;
    end;
  do return min end;
end
hsluv.Hsluv.dotProduct = function(a,b) 
  local sum = 0;
  local _g1 = 0;
  local _g = a.length;
  while (_g1 < _g) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    sum = sum + (a[i] * b[i]);
    end;
  do return sum end;
end
hsluv.Hsluv.fromLinear = function(c) 
  if (c <= 0.0031308) then 
    do return 12.92 * c end;
  else
    do return (1.055 * _G.math.pow(c,0.41666666666666669)) - 0.055 end;
  end;
end
hsluv.Hsluv.toLinear = function(c) 
  if (c > 0.04045) then 
    do return _G.math.pow((c + 0.055) / 1.055,2.4) end;
  else
    do return c / 12.92 end;
  end;
end
hsluv.Hsluv.xyzToRgb = function(tuple) 
  do return _hx_tab_array({[0]=hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[0],tuple)), hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[1],tuple)), hsluv.Hsluv.fromLinear(hsluv.Hsluv.dotProduct(hsluv.Hsluv.m[2],tuple)) }, 3) end;
end
hsluv.Hsluv.rgbToXyz = function(tuple) 
  local rgbl = _hx_tab_array({[0]=hsluv.Hsluv.toLinear(tuple[0]), hsluv.Hsluv.toLinear(tuple[1]), hsluv.Hsluv.toLinear(tuple[2]) }, 3);
  do return _hx_tab_array({[0]=hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[0],rgbl), hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[1],rgbl), hsluv.Hsluv.dotProduct(hsluv.Hsluv.minv[2],rgbl) }, 3) end;
end
hsluv.Hsluv.yToL = function(Y) 
  if (Y <= hsluv.Hsluv.epsilon) then 
    do return (Y / hsluv.Hsluv.refY) * hsluv.Hsluv.kappa end;
  else
    do return (116 * _G.math.pow(Y / hsluv.Hsluv.refY,0.33333333333333331)) - 16 end;
  end;
end
hsluv.Hsluv.lToY = function(L) 
  if (L <= 8) then 
    do return (hsluv.Hsluv.refY * L) / hsluv.Hsluv.kappa end;
  else
    do return hsluv.Hsluv.refY * _G.math.pow((L + 16) / 116,3) end;
  end;
end
hsluv.Hsluv.xyzToLuv = function(tuple) 
  local X = tuple[0];
  local Y = tuple[1];
  local Z = tuple[2];
  local divider = (X + (15 * Y)) + (3 * Z);
  local varU = 4 * X;
  local varV = 9 * Y;
  if (divider ~= 0) then 
    varU = varU / divider;
    varV = varV / divider;
  else
    varU = (0/0);
    varV = (0/0);
  end;
  local L = hsluv.Hsluv.yToL(Y);
  if (L == 0) then 
    do return _hx_tab_array({[0]=0, 0, 0 }, 3) end;
  end;
  local U = (13 * L) * (varU - hsluv.Hsluv.refU);
  local V = (13 * L) * (varV - hsluv.Hsluv.refV);
  do return _hx_tab_array({[0]=L, U, V }, 3) end;
end
hsluv.Hsluv.luvToXyz = function(tuple) 
  local L = tuple[0];
  local U = tuple[1];
  local V = tuple[2];
  if (L == 0) then 
    do return _hx_tab_array({[0]=0, 0, 0 }, 3) end;
  end;
  local varU = (U / (13 * L)) + hsluv.Hsluv.refU;
  local varV = (V / (13 * L)) + hsluv.Hsluv.refV;
  local Y = hsluv.Hsluv.lToY(L);
  local X = 0 - (((9 * Y) * varU) / (((varU - 4) * varV) - (varU * varV)));
  local Z = (((9 * Y) - ((15 * varV) * Y)) - (varV * X)) / (3 * varV);
  do return _hx_tab_array({[0]=X, Y, Z }, 3) end;
end
hsluv.Hsluv.luvToLch = function(tuple) 
  local L = tuple[0];
  local U = tuple[1];
  local V = tuple[2];
  local C = _G.math.sqrt((U * U) + (V * V));
  local H;
  if (C < 0.00000001) then 
    H = 0;
  else
    local Hrad = _G.math.atan2(V,U);
    H = (Hrad * 180.0) / 3.1415926535897932;
    if (H < 0) then 
      H = 360 + H;
    end;
  end;
  do return _hx_tab_array({[0]=L, C, H }, 3) end;
end
hsluv.Hsluv.lchToLuv = function(tuple) 
  local L = tuple[0];
  local C = tuple[1];
  local H = tuple[2];
  local Hrad = ((H / 360.0) * 2) * _G.math.pi;
  local U = _G.math.cos(Hrad) * C;
  local V = _G.math.sin(Hrad) * C;
  do return _hx_tab_array({[0]=L, U, V }, 3) end;
end
hsluv.Hsluv.hsluvToLch = function(tuple) 
  local H = tuple[0];
  local S = tuple[1];
  local L = tuple[2];
  if (L > 99.9999999) then 
    do return _hx_tab_array({[0]=100, 0, H }, 3) end;
  end;
  if (L < 0.00000001) then 
    do return _hx_tab_array({[0]=0, 0, H }, 3) end;
  end;
  local max = hsluv.Hsluv.maxChromaForLH(L,H);
  local C = (max / 100) * S;
  do return _hx_tab_array({[0]=L, C, H }, 3) end;
end
hsluv.Hsluv.lchToHsluv = function(tuple) 
  local L = tuple[0];
  local C = tuple[1];
  local H = tuple[2];
  if (L > 99.9999999) then 
    do return _hx_tab_array({[0]=H, 0, 100 }, 3) end;
  end;
  if (L < 0.00000001) then 
    do return _hx_tab_array({[0]=H, 0, 0 }, 3) end;
  end;
  local max = hsluv.Hsluv.maxChromaForLH(L,H);
  local S = (C / max) * 100;
  do return _hx_tab_array({[0]=H, S, L }, 3) end;
end
hsluv.Hsluv.hpluvToLch = function(tuple) 
  local H = tuple[0];
  local S = tuple[1];
  local L = tuple[2];
  if (L > 99.9999999) then 
    do return _hx_tab_array({[0]=100, 0, H }, 3) end;
  end;
  if (L < 0.00000001) then 
    do return _hx_tab_array({[0]=0, 0, H }, 3) end;
  end;
  local max = hsluv.Hsluv.maxSafeChromaForL(L);
  local C = (max / 100) * S;
  do return _hx_tab_array({[0]=L, C, H }, 3) end;
end
hsluv.Hsluv.lchToHpluv = function(tuple) 
  local L = tuple[0];
  local C = tuple[1];
  local H = tuple[2];
  if (L > 99.9999999) then 
    do return _hx_tab_array({[0]=H, 0, 100 }, 3) end;
  end;
  if (L < 0.00000001) then 
    do return _hx_tab_array({[0]=H, 0, 0 }, 3) end;
  end;
  local max = hsluv.Hsluv.maxSafeChromaForL(L);
  local S = (C / max) * 100;
  do return _hx_tab_array({[0]=H, S, L }, 3) end;
end
hsluv.Hsluv.rgbToHex = function(tuple) 
  local h = "#";
  local _g = 0;
  while (_g < 3) do 
    _g = _g + 1;
    local i = _g - 1;
    local chan = tuple[i];
    local c = _G.math.floor((chan * 255) + 0.5);
    local digit2 = _G.math.fmod(c, 16);
    local digit1 = Std.int((c - digit2) / 16);
    h = h .. (hsluv.Hsluv.hexChars:charAt(digit1) .. hsluv.Hsluv.hexChars:charAt(digit2));
    end;
  do return h end;
end
hsluv.Hsluv.hexToRgb = function(hex) 
  hex = hex:toLowerCase();
  local ret = _hx_tab_array({ }, 0);
  local _g = 0;
  while (_g < 3) do 
    _g = _g + 1;
    local i = _g - 1;
    local digit1 = hsluv.Hsluv.hexChars:indexOf(hex:charAt((i * 2) + 1));
    local digit2 = hsluv.Hsluv.hexChars:indexOf(hex:charAt((i * 2) + 2));
    local n = (digit1 * 16) + digit2;
    ret:push(n / 255.0);
    end;
  do return ret end;
end
hsluv.Hsluv.lchToRgb = function(tuple) 
  do return hsluv.Hsluv.xyzToRgb(hsluv.Hsluv.luvToXyz(hsluv.Hsluv.lchToLuv(tuple))) end;
end
hsluv.Hsluv.rgbToLch = function(tuple) 
  do return hsluv.Hsluv.luvToLch(hsluv.Hsluv.xyzToLuv(hsluv.Hsluv.rgbToXyz(tuple))) end;
end
hsluv.Hsluv.hsluvToRgb = function(tuple) 
  do return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hsluvToLch(tuple)) end;
end
_hx_exports["hsluv"]["Hsluv"]["hsluvToRgb"] = hsluv.Hsluv.hsluvToRgb
hsluv.Hsluv.rgbToHsluv = function(tuple) 
  do return hsluv.Hsluv.lchToHsluv(hsluv.Hsluv.rgbToLch(tuple)) end;
end
_hx_exports["hsluv"]["Hsluv"]["rgbToHsluv"] = hsluv.Hsluv.rgbToHsluv
hsluv.Hsluv.hpluvToRgb = function(tuple) 
  do return hsluv.Hsluv.lchToRgb(hsluv.Hsluv.hpluvToLch(tuple)) end;
end
_hx_exports["hsluv"]["Hsluv"]["hpluvToRgb"] = hsluv.Hsluv.hpluvToRgb
hsluv.Hsluv.rgbToHpluv = function(tuple) 
  do return hsluv.Hsluv.lchToHpluv(hsluv.Hsluv.rgbToLch(tuple)) end;
end
_hx_exports["hsluv"]["Hsluv"]["rgbToHpluv"] = hsluv.Hsluv.rgbToHpluv
hsluv.Hsluv.hsluvToHex = function(tuple) 
  do return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hsluvToRgb(tuple)) end;
end
_hx_exports["hsluv"]["Hsluv"]["hsluvToHex"] = hsluv.Hsluv.hsluvToHex
hsluv.Hsluv.hpluvToHex = function(tuple) 
  do return hsluv.Hsluv.rgbToHex(hsluv.Hsluv.hpluvToRgb(tuple)) end;
end
_hx_exports["hsluv"]["Hsluv"]["hpluvToHex"] = hsluv.Hsluv.hpluvToHex
hsluv.Hsluv.hexToHsluv = function(s) 
  do return hsluv.Hsluv.rgbToHsluv(hsluv.Hsluv.hexToRgb(s)) end;
end
_hx_exports["hsluv"]["Hsluv"]["hexToHsluv"] = hsluv.Hsluv.hexToHsluv
hsluv.Hsluv.hexToHpluv = function(s) 
  do return hsluv.Hsluv.rgbToHpluv(hsluv.Hsluv.hexToRgb(s)) end;
end
_hx_exports["hsluv"]["Hsluv"]["hexToHpluv"] = hsluv.Hsluv.hexToHpluv

lua.Boot.new = {}
lua.Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
lua.Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(o[0]) .. "(";
    s = s .. "\t";
    local _g1 = 2;
    local _g = o.length;
    while (_g1 < _g) do 
      _g1 = _g1 + 1;
      local i = _g1 - 1;
      if (i ~= 2) then 
        str = str .. ("," .. lua.Boot.__string_rec(o[i],s));
      else
        str = str .. lua.Boot.__string_rec(o[i],s);
      end;
      end;
    do return str .. ")" end;
  end;
end
lua.Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = lua.Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
lua.Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  local _g = type(o);
  local _g1 = _g;
  if (_g1) == "boolean" then 
    do return tostring(o) end;
  elseif (_g1) == "function" then 
    do return "<function>" end;
  elseif (_g1) == "nil" then 
    do return "null" end;
  elseif (_g1) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o ~= o) then 
          do return "NaN" end;
        else
          do return tostring(o) end;
        end;
      end;
    end;
  elseif (_g1) == "string" then 
    do return o end;
  elseif (_g1) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return lua.Boot.printEnum(o,s) end;
    else
      if ((o.toString ~= nil) and not lua.Boot.isArray(o)) then 
        do return o:toString() end;
      else
        if (lua.Boot.isArray(o)) then 
          local o2 = o;
          if (s.length > 5) then 
            do return "[...]" end;
          else
            local _g2 = _hx_tab_array({ }, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g2:push(lua.Boot.__string_rec(i,s .. 1));
              end;
            do return "[" .. _g2:join(",") .. "]" end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return "{" .. lua.Boot.printClassRec(o,"",s .. "\t") .. "}" end;
          else
            local fields = lua.Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer,"{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer,", ");
              end;
              _G.table.insert(buffer,"" .. Std.string(f1) .. " : " .. Std.string(o[f1]));
              end;
            _G.table.insert(buffer," }");
            do return _G.table.concat(buffer,"") end;
          end;
        end;
      end;
    end;
  elseif (_g1) == "thread" then 
    do return "<thread>" end;
  elseif (_g1) == "userdata" then 
    do return "<userdata>" end;else
  _G.error("Unknown Lua type",0); end;
end
lua.Boot.fieldIterator = function(o) 
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (lua.Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1,val);
      end;
    do return val end;
  end;
  local cur_val = next_valid(tbl,cur(tbl,nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl,cur(tbl,cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end
_hx_bit_clamp = function(v) 
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end
pcall(require, 'bit')
if bit then
  _hx_bit = bit
elseif bit32 then
  local _hx_bit_raw = bit32
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
local _hx_string_mt = _G.getmetatable('');
String.__oldindex = _hx_string_mt.__index;
_hx_string_mt.__index = String.__index;
_hx_string_mt.__add = function(a,b) return Std.string(a)..Std.string(b) end;
_hx_string_mt.__concat = _hx_string_mt.__add
_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  hsluv.Hsluv.m = _hx_tab_array({[0]=_hx_tab_array({[0]=3.240969941904521, -1.537383177570093, -0.498610760293 }, 3), _hx_tab_array({[0]=-0.96924363628087, 1.87596750150772, 0.041555057407175 }, 3), _hx_tab_array({[0]=0.055630079696993, -0.20397695888897, 1.056971514242878 }, 3) }, 3)
  hsluv.Hsluv.minv = _hx_tab_array({[0]=_hx_tab_array({[0]=0.41239079926595, 0.35758433938387, 0.18048078840183 }, 3), _hx_tab_array({[0]=0.21263900587151, 0.71516867876775, 0.072192315360733 }, 3), _hx_tab_array({[0]=0.019330818715591, 0.11919477979462, 0.95053215224966 }, 3) }, 3)
  hsluv.Hsluv.refY = 1.0
  hsluv.Hsluv.refU = 0.19783000664283
  hsluv.Hsluv.refV = 0.46831999493879
  hsluv.Hsluv.kappa = 903.2962962
  hsluv.Hsluv.epsilon = 0.0088564516
  hsluv.Hsluv.hexChars = "0123456789abcdef"
  lua.Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
end

_hx_static_init();
return _hx_exports
